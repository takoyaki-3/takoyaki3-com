name: Q&A (Gemini-CLI)

on:
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write

concurrency:
  group: qa-gemini-${{ github.event.issue.number }}
  cancel-in-progress: false

jobs:
  answer:
    if: ${{ startsWith(github.event.comment.body, '/ask ') && github.event.comment.user.type != 'Bot' && (github.event.comment.author_association == 'MEMBER' || github.event.comment.author_association == 'OWNER' || github.event.comment.author_association == 'COLLABORATOR') }}
    runs-on: ubuntu-latest

    env:
      GEMINI_MODEL: gemini-2.5-pro

    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install jq (if missing)
        shell: bash
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Install Gemini CLI (multiple candidates)
        shell: bash
        run: |
          set -euxo pipefail
          # 代表的な CLI を順に試す
          npm i -g gemini-cli || true
          npm i -g @google/generative-ai-cli || true

          if command -v gemini >/dev/null 2>&1; then
            echo "GEMINI_BIN=$(command -v gemini)" >> "$GITHUB_ENV"
          else
            echo "Gemini CLI (gemini) が見つかりません。インストール方法を見直してください。" >&2
            exit 1
          fi

      - name: Extract question
        id: q
        shell: bash
        run: |
          Q=$(printf "%s" "${{ github.event.comment.body }}" | sed -E 's#^/ask[[:space:]]+##')
          {
            echo "question<<'EOF'"
            printf "%s\n" "$Q"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Ask via Gemini CLI
        id: gen
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GEMINI_MODEL: ${{ env.GEMINI_MODEL }}
          GEMINI_BIN: ${{ env.GEMINI_BIN }}
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${GEMINI_API_KEY:-}" ]; then
            echo "Missing secret GEMINI_API_KEY" >&2
            exit 1
          fi
          echo "::add-mask::$GEMINI_API_KEY"

          QUESTION=${{ steps.q.outputs.question }}
          TMP=/tmp/answer.txt

          # いくつかの CLI 方言に対応したフォールバック実行
          try_run() {
            set +e
            eval "$1" >"$TMP".raw 2>"$TMP".err
            code=$?
            set -e
            return $code
          }

          # 候補コマンド（いずれかが成功すれば OK）
          CANDIDATES=(
            # stdin を渡す一般形（--input -）
            "printf %s \"\$QUESTION\" | \"$GEMINI_BIN\" --model \"\$GEMINI_MODEL\" --api-key \"\$GEMINI_API_KEY\" --input -"
            # -p 指定（プロンプト引数）
            "\"$GEMINI_BIN\" --model \"\$GEMINI_MODEL\" --api-key \"\$GEMINI_API_KEY\" -p \"\$QUESTION\""
            # サブコマンド系（prompts send）
            "\"$GEMINI_BIN\" prompts send -m \"\$GEMINI_MODEL\" --api-key \"\$GEMINI_API_KEY\" --text \"\$QUESTION\""
            # サブコマンド系（generate）
            "\"$GEMINI_BIN\" generate -m \"\$GEMINI_MODEL\" --api-key \"\$GEMINI_API_KEY\" --text \"\$QUESTION\""
          )

          ok=0
          for cmd in "${CANDIDATES[@]}"; do
            echo "Trying: $cmd"
            if try_run "$cmd"; then
              ok=1
              break
            fi
          done

          if [ "$ok" -ne 1 ]; then
            echo "Gemini CLI 実行に失敗しました。エラーログ:"
            sed -n '1,200p' "$TMP".err || true
            exit 1
          fi

          # 出力が JSON/テキストのどちらでも扱えるように整形
          if jq -e . >/dev/null 2>&1 <"$TMP".raw; then
            # 代表的な JSON 形式からテキストを抽出（なければ全体）
            text="$(jq -r '
              .text // .output // .response // .candidates[0].content.parts
              | if type=="array" then map(.text // .content // tostring) | join("\n")
                else .
                end
              ' < "$TMP".raw)"
            if [ -z "$text" ] || [ "$text" = "null" ]; then
              text="$(cat "$TMP".raw)"
            fi
          else
            # そのままテキストとして扱う
            text="$(cat "$TMP".raw)"
          fi

          # コメント安全長にトリム
          printf "%s" "$text" | head -c 60000 > "$TMP"

      - name: Reply as comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const body = fs.readFileSync('/tmp/answer.txt','utf8');
            await github.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body
            });
